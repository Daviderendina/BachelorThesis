\section{Conclusioni e sviluppi futuri}
Questo elaborato ha presentato il mio lavoro svolto per l'estensione del tool Arcan \cite{Arcan2017}, riguardante l'implementazione degli algoritmi di \textit{detection} per l'analisi di tre nuovi \textit{architectural smells}, di cui uno relativo a problemi di gerarchia (\textit{Subclasses Do Not Redefine Methods}) e due riguardanti \textit{smell} che violano il principio di astrazione (\textit{Unutilizied Abstraction} e \textit{Unnecessary Abstraction)}. Oltre agli \textit{smell} e alle strategie di identificazione e algoritmi ideati, sono state presentate anche le modifiche effettuate al \textit{parsing} e al grafo delle dipendenze, necessarie per la rappresentazione di informazioni riguardanti funzioni e attributi richiesti dai nuovi \textit{smell}.
    %con l'obiettivo di implementare il riconoscimento di tre nuove tipologie di \textit{Architectural Smells}, di cui uno relativo a problemi di gerarchia (\textit{Subclasses Do Not Redefine Methods}) e due riguardanti \textit{smell} che violano il principio di astrazione (\textit{Unutilizied Abstraction} e \textit{Unnecessary Abstraction)}. Sono state necessarie modifiche al grafo delle dipendenze e agli algoritmi di \textit{parsing}, per la rappresentazione delle funzioni e degli attributi, fondamentali per l'implementazione degli algoritmi di \textit{detection} dei nuovi \textit{smell}. 
    
È stata analizzata nel dettaglio la fase di validazione degli algoritmi, con analisi dei falsi positivi riscontrati e del valore di \textit{precision} degli stessi. 
In particolare, è stato calcolato un valore di questa metrica pari a 89.75\% per quanto riguarda \textit{Subclasses Do Not Redefine Methods}, mentre \textit{Unutilizied Abstraction} e \textit{Unnecessary Abstraction} hanno registrato una \textit{precision} rispettivamente di 95.43\% e 73.66\%.

È presente infine una sezione riguardante il confronto tra Arcan e Designite, 
    %Il lavoro svolto ha attraversato poi una fase di \textit{detection} degli algoritmi e validazione su dieci progetti open-source, al fine di calcolare la precisione di Arcan nella detection di questi \textit{smell}. Sono state effettuate inoltre diverse analisi sui valori ottenuti dalla validazione e un confronto riguardante la \textit{detection} di Arcan e il \textit{tool} Designite \cite{Designite}, 
in grado di riconoscere tutti e tre gli \textit{smell} introdotti in questo elaborato, che ha visto un'analisi approfondita delle differenze riguardanti le strategie di detection adottate dai \textit{tool} e i risultati ottenuti.
    %Sono stati inoltre presentati i risultati ottenuto lanciando gli algoritmi di detection su 10 progetti open source e la validazione di essi, con un'analisi approfondita delle cause che hanno portato gli algoritmi a trovare anche alcuni casi di falsi positivi tra i risultati.

La struttura di Arcan lo rende molto flessibile dal punto di vista dell'aggiunta di nuove caratteristiche, come può essere per nuovi algoritmi di \textit{detection}, \textit{parsing} di nuovi linguaggi e modifiche al grafo delle dipendenze, e potrà continuare quindi ad essere esteso per ampliare il suo raggio di azione e le sue capacità. %, nonché per essere fornito di un'efficace interfaccia utente che ne semplifichi l'utilizzo.

Ulteriore lavoro invece può essere svolto riguardo agli \textit{smell} da me introdotti. Sarebbe possibile infatti studiare nuovi filtri per la rimozione di casi di falsa positività con conseguente aumento della \textit{precision} degli algoritmi. Inoltre potrebbero essere introdotte nuove casistiche nell'ambito di \textit{Unnecessary Abstraction}, previo studio di nuovi problemi che possono introdurre classi non necessarie al design.

Un'ulteriore modifica ad Arcan potrebbe essere l'aggiunta del \textit{refactoring} automatico di alcuni \textit{smell} trovati, proponendo all'utente la soluzione più congeniale per la risoluzione dello stesso. 
Nel caso di progetti Java infatti, grazie alle librerie utilizzate è possibile la modifica di tutti gli elementi che compongono un programma. Questa possibilità di \textit{refactoring} automatico può adattarsi molto bene ad esempio nei casi \textit{over-engineered} di \textit{Unnecessary Abstraction}.
